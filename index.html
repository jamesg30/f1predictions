<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Predictions</title>
    <link rel="icon" href="/media/f1_predictions_logo.ico" type="image/x-icon">
    <!-- Bootstrap CSS (Local) -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/style.css">
    <style> 
        /* Container for the image and overlay */
        .full-width-image-container {
            position: relative; /* Allows for absolute positioning of overlay */
            width: 100%;        /* Full width of the container */
            height: 180px;      /* Fixed height for the image */
            overflow: hidden;   /* Prevents anything from overflowing */
        }

        /* Image styling */
        .full-width-image {
            width: 100%;        /* Full width of the container */
            height: 100%;       /* Full height of the container */
            object-fit: cover;  /* Ensures the image scales proportionally and fills the container */
        }

        /* Transparent overlay styling */
        .overlay {
            position: absolute;   /* Positioned relative to the parent container */
            top: 0;               /* Start at the top of the container */
            left: 0;              /* Start at the left of the container */
            width: 100%;          /* Full width of the container */
            height: 100%;         /* Full height of the container (200px) */
            background-color: rgba(0, 0, 0, 0.4); /* Transparent black overlay */
        }
        .chart-wrapper {
    width: 100%; /* Let it fill the width */
    max-width: 900px; /* Prevent it from becoming too wide */
    height: 400px; /* Fixed height */
    margin: 0 auto; /* Center it */
    padding: 0 20px; /* Add padding on desktop */
}

.flag-img {
  width: 64px;
  height: 36px;
  image-rendering: pixelated;
  /* 8-bit style shadow: crisp, no blur, offset to bottom-right */
  box-shadow: 4px 4px 0px #a0a0a0;
}

@media (max-width: 768px) {
    .chart-wrapper {
        height: 500px; /* Increase height on smaller screens */
        padding: 0 10px; /* Reduce padding */
    }
}

    </style>
        <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Initialize Supabase globally
        const supabaseUrl = 'https://mbyhlefxnjjzmiwsvnaa.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ieWhsZWZ4bmpqem1pd3N2bmFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQzODQwOTgsImV4cCI6MjA0OTk2MDA5OH0.4gcUcOfhyTspbcDn6gPxBKFSTu3zUbkBdNEhMq9MdnY';
        var supabase = supabase.createClient(supabaseUrl, supabaseKey);
    </script>
    <!-- Encryption Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <!-- script.js import -->
    <script type="module" src="/script.js"></script>
</head>
<body>
    <div id="alert-container" class="position-fixed top-0 start-50 translate-middle-x" style="z-index: 9999;"></div>
   <!-- HEADER -->
<header class="bg-light text-black py-2.5 d-flex align-items-center justify-content-between sticky-top">
    <!-- Left Section: Logo and Heading -->
    <div class="d-flex align-items-center">
      <a href="/" class="ms-2.5 me-2 d-flex align-items-center">
        <img src="/media/f1_predictions_logo.png" alt="Logo" style="height: 45px;">
      </a>
      <a href="/" class="text-decoration-none text-black">
        <h5 class="mb-0 pixel-art-heading-2" style="font-size: 1.1rem;">F1 Predictions</h5>
      </a>
    </div>
  
    <!-- Right Section: User Avatar and Hamburger Menu -->
    <div class="d-flex align-items-center">
      <!-- Pixel Avatar (initially hidden) -->
      <div id="user-avatar" class="user-avatar d-none me-2"></div>
      <!-- Hamburger Menu Dropdown -->
      <div class="pixel-dropdown me-3">
        <button class="pixel-button" type="button" id="hamburgerMenu" data-bs-toggle="dropdown" aria-expanded="false">
          Menu
        </button>
        <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="hamburgerMenu">
          <!-- Other Menu Items -->
          <li><a class="dropdown-item pixel-art-body-smallxb" href="/">Home</a></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/form">Form</a></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/teams">Teams</a></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/results">Results</a></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/register">Register</a></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/feedback">Feedback</a></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/info">Info</a></li>
          <!--<li><a class="dropdown-item pixel-art-body-smallx" href="/archive">Archive</a></li>-->
          <li><a class="dropdown-item pixel-art-body-smallx" href="/account">Account</a></li>
          <li><hr class="dropdown-divider"></li>
          <!-- Login/Logout Items -->
          <li id="loggedInUserDisplay" class="dropdown-item-text d-none pixel-art-body-smallx" style="color: darkgrey">
            Logged in as <strong></strong>
          </li>
          <li id="logoutMenuItem" class="d-none">
            <a class="dropdown-item logout-link pixel-art-body-smallx" href="#" id="logoutBtn">
                Log Out
            </a>
          </li>
          <li id="loginMenuItem">
            <a class="dropdown-item pixel-art-body-smallx" href="#" data-bs-toggle="modal" data-bs-target="#loginModal">
              Log In
            </a>
          </li>
          <li><hr class="dropdown-divider"></li>
          <li><a class="dropdown-item pixel-art-body-smallx" href="/admin">Admin</a></li>
        </ul>
      </div>
    </div>
  </header>
  

    <!-- Full-Width Image Section with Centered Text -->
        <section class="full-width-image-container">
            <img src="/media/ferrari_background.png" alt="Full Width Image" class="full-width-image">
            <div class="overlay"></div> <!-- Transparent black layer -->

            <!-- Centered Text -->
            <h2  class="centered-text-pixel-art-heading">F1 Predictions Form</h2>
        </section>

    <main class="container my-5">
        <div class="row g-4">
            <!-- Left Column: Latest Form -->
            <div class="col-md-6">
                <div class="text-center">
                    <h5 class="mb-3 pixel-art-body">Latest Form:</h5>
                    <a id="latest-form-link">
                        <button id="latest-form-button" type="button" class="pixel-button" disabled>Loading...</button>
                    </a>
                    <div id="formStatusContainer" style="display: none; margin-top: 15px">
                        <i id="formStatusText" class="mb-3 pixel-art-body"></i>
                    </div>
                </div>
            </div>
    
    <!-- Right Column: Quick Links -->
        <div class="col-md-6">
            <div class="text-center">
                <h5 class="mb-3 pixel-art-body">Quick Links:</h5>
                <!-- Changed to flex-row for horizontal alignment -->
                <div class="d-flex flex-row justify-content-center gap-3">
                    <a href="/results">
                        <button type="button" class="pixel-button">Results</button>
                    </a>
                    <a href="/teams">
                        <button type="button" class="pixel-button">Teams</button>
                    </a>
                </div>
            </div>
        </div>

        </div>
    
    <!-- Next Race Section -->
        <div class="text-center mt-5">
            <h5 class="pixel-art-body">Next Race:</h5>
            <div id="next-race-info" class="mt-3">
                <p class="pixel-art-body-small">Loading next race...</p>
            </div>
        </div>
        <hr>
        <!-- Loading Indicator for Scored Results -->
        <div id="loadingPlaceholderBar" class="loading-indicator mb-3 pixel-art-heading-2">
            <div class="container my-3 d-flex justify-content-left">
                <h4 class="mb-3 pixel-art-heading-3">Loading...</h4>
            </div>
            Loading...
            <div class="loading-bar"></div>
        </div>
        <!-- Scored Results Section -->
        <div id="scoredResults" style="display: none;"> <!-- Scored Results Placeholder -->
            <div class="container my-3 d-flex justify-content-left">
                <h4 class="mb-3 pixel-art-heading-3">Latest Results</h4>
            </div>
            <div class="container my-4">
                <h5 id="raceTitle" class="mb-3 pixel-art-heading-2"></h5>
                <!-- Loading Indicator for Scored Results -->
                <div id="scoredLoading" class="loading-indicator mb-3 pixel-art-heading-2">
                    Results loading...
                    <div class="loading-bar"></div>
                </div>
                <table id="resultsTable">
                    <tbody>
                        <tr>
                            <td style="vertical-align: middle;">
                                <p>
                                    <img src="/media/awards/medal_first.png" style="float:left; width: 16px; height: 26px; image-rendering: pixelated; margin-right: 10px;">
                                    <span id="firstPlace" class="pixel-art-body"></span>
                                </p>
                            </td>
                            <td style="vertical-align: middle;">
                                <p>
                                    <img src="/media/awards/medal_second.png" style="float:left; width: 16px; height: 26px; image-rendering: pixelated; margin-right: 10px; margin-left: 10px;">
                                    <span id="secondPlace" class="mb-3 pixel-art-body"></span>
                                </p>
                            </td>
                            <td style="vertical-align: middle;">
                                <p>
                                    <img src="/media/awards/medal_third.png" style="float:left; width: 16px; height: 26px; image-rendering: pixelated; margin-right: 10px; margin-left: 10px;">
                                    <span id="thirdPlace" class="mb-3 pixel-art-body"></span>
                                </p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            
                <!-- Scrollable container for main results table -->
                <div class="table-responsive" style="overflow-x: auto; max-width: 100%;">
                    <table id="mainResultsTable" class="table table-sm table-bordered">
                        <thead id="tableHeader">
                            <!-- Header row will be inserted here -->
                        </thead>
                        <tbody id="tableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
                <div class="form-check form-switch">
                    <label class="form-check-label" for="toggleScores">Show Detailed Scoring</label>
                    <input class="form-check-input form-switch-input" type="checkbox" id="toggleScores">
                </div>
                <div id="lowestScores" class="mt-3">
                    <!-- Lowest scores will be displayed here -->
                </div>
            </div>
        </div>

    <!-- Unscored Predictions Section -->
        <div id="unscoredPredictions" style="display: none;"> <!-- Unscored Predictions Placeholder -->
            <div class="container my-3 d-flex justify-content-left">
                <h4 class="mb-3 pixel-art-heading-3">Unscored Predictions</h4>
            </div>
            <div class="container my-4">
                <h5 id="unscoredRaceTitle" class="mb-3 pixel-art-heading-2"></h5>
                <!-- Loading Indicator for Unscored Predictions -->
                <div id="unscoredLoading" class="loading-indicator mb-3 pixel-art-heading-2">
                    Predictions loading...
                    <div class="loading-bar"></div>
                </div>
                <!-- Scrollable container for unscored results table -->
                <div class="table-responsive" style="overflow-x: auto; max-width: 100%;">
                    <table id="unscoredResultsTable" class="table table-sm table-bordered">
                        <thead id="unscoredTableHeader">
                            <!-- Header row will be inserted here -->
                        </thead>
                        <tbody id="unscoredTableBody">
                            <!-- Data rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

    <!-- No Display Section -->
        <div id="noDisplay" style="display: none;"> <!-- No Display Placeholder -->
            <div class="container my-3 d-flex justify-content-left">
                <h4 class="mb-3 pixel-art-heading-2">No results to display</h4>
            </div>
        </div>
        
        <hr>
        <h3 class="pixel-art-heading-3" style="margin-top: 15px; margin-bottom: 15px">Season Standings</h3>
        <div class="row g-4">
            <!-- Left Column: Latest Form -->
            <!-- Left Column: Latest Form / Player Standings -->
                <div class="col-md-6">
                    <h5 class="mb-3 pixel-art-heading-2">Player Standings</h5>
                    <table id="standings-table" class="table table-sm table-bordered">
                    <thead>
                        <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Standings rows will be injected here by JavaScript -->
                    </tbody>
                    </table>
                </div>

            <!-- Right Column: Quick Links -->
            <div class="col-md-6">
                <h5 class="mb-3 pixel-art-heading-2">Team Standings</h5>
                <table id="standings-team-table" class="table table-sm table-bordered">
                  <thead>
                    <tr>
                      <th>Rank</th>
                      <th>Team</th>
                      <th>Score</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Team standings will be inserted here dynamically -->
                  </tbody>
                </table>
              </div>

              <div class="container mt-4">
                <div class="chart-wrapper">
                    <canvas id="standings-line-chart"></canvas>
                </div>                
                <div class="chart-wrapper">
                    <canvas id="standings-team-line-chart"></canvas>
                </div>                
              </div>
        <hr>
        <div class="container my-5">
            <pre class="mb-3 pixel-art-heading-3"><img src="/media/awards/trophy.png" style="float:left; width: 32px; height: 38px; image-rendering: pixelated;"> Past Champions</pre>
            <p>
                2024 - James<br>
                2023 - Ethan<br>
                2022 - Ethan
            </p>
        </div>

<!-- LOGIN MODAL -->
<div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title pixel-art-heading-2" id="loginModalLabel">Login</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <form id="login-form">
            <div class="mb-3">
              <label for="login-player-name" class="form-label pixel-art-body">Select Player</label>
              <select id="login-player-name" class="form-select pixel-art-body" required>
                <!-- Options populated dynamically -->
              </select>
            </div>
            <div class="mb-3">
                <label for="login-pin" class="form-label pixel-art-body">Enter PIN</label>
                <input type="password" id="login-pin" class="form-control pixel-art-body" maxlength="4" pattern="\d*" inputmode="numeric" required />
              </div>
              
            <div class="mb-3">
              <label for="rememberMe" class="form-check-label pixel-art-body">
                <input type="checkbox" id="rememberMe" class="form-check-input pixel-art-body" />
                Remember me
              </label>
            </div>
            <button type="submit" class="pixel-button">Login</button>
          </form>
        </div>
      </div>
    </div>
  </div>

    </main>
 
    <footer class="bg-light text-black text-center py-1 pixel-art-body-smallx">
        <p>&copy; 2025 F1 Predictions Form</p>
    </footer>

    <!-- Bootstrap JS Bundle (Local) -->
    <script src="/js/bootstrap.bundle.min.js"></script>

    <script>
        // Fetch the race details from form_details and calendar tables
        async function fetchRaceDetails() {
            try {
                // Fetch the race number from form_details
                const { data: formDetails, error: formDetailsError } = await supabase
                    .from('form_details')
                    .select('race_number')
                    .eq('id', 1)
                    .single();
    
                if (formDetailsError) {
                    console.error('Error fetching form details:', formDetailsError);
                    return null;
                }
    
                const raceNumber = formDetails.race_number;
    
                // Fetch the race details from the calendar table
                const { data: raceDetails, error: raceDetailsError } = await supabase
                    .from('calendar')
                    .select('*')
                    .eq('race_number', raceNumber)
                    .single();
    
                if (raceDetailsError) {
                    console.error('Error fetching race details:', raceDetailsError);
                    return null;
                }
    
                return raceDetails;
            } catch (error) {
                console.error('Error fetching race details:', error);
                return null;
            }
        }
    
        // Update the latest form button with the current race name
        async function updateLatestFormButton(raceDetails) {
            if (raceDetails) {
                document.getElementById("latest-form-button").textContent = `${raceDetails.name} GP Form`;
            } else {
                document.getElementById("latest-form-button").textContent = "Error loading form";
            }
        }
    
        async function updateNextRaceInfo(raceDetails) {
        if (!raceDetails) {
            document.getElementById("next-race-info").innerHTML = "<p>Error loading next race.</p>";
            return;
        }

        const raceDate = new Date(raceDetails.date);
        if (isNaN(raceDate)) {
            console.error("Invalid date format for next race:", raceDetails.date);
            document.getElementById("next-race-info").innerHTML = "<p>Invalid race date.</p>";
            return;
        }

        const flagUrl = `/media/flags/${raceDetails.country.toLowerCase()}.png`;

        document.getElementById("next-race-info").innerHTML = `
  <img src="${flagUrl}" alt="${raceDetails.country} Flag" class="flag-img">
  <h6 class="mt-2 pixel-art-body-small">${raceDetails.name} GP</h6>
  <div id="countdown-timer" class="mt-2" style="font-size: 0.8rem; text-align: center; display: inline-block;">
      <strong>Time left:</strong> <span id="countdown"></span>
  </div>
`;


        // Show the countdown container (it should now size to its content)
        document.getElementById("countdown-timer").style.display = "inline-block";

        // Start the generic countdown as before
        startGenericCountdown(raceDate, "countdown", function() {
        const countdownEl = document.getElementById("countdown");
        countdownEl.style.color = "white";
        });
        }
    
        /**
 * startGenericCountdown:
 * Starts a countdown that updates every second.
 * @param {Date} targetDate - The date/time to count down to.
 * @param {string} countdownElementId - The id of the element where the countdown text will be displayed.
 * @param {function} [onEnd] - Optional callback to execute when countdown ends.
 */
        function startGenericCountdown(targetDate, countdownElementId, onEnd) {
        const countdownElement = document.getElementById(countdownElementId);
        if (!countdownElement) {
            console.error(`Element with id "${countdownElementId}" not found.`);
            return;
        }
        
        let timer;
        
        function updateCountdown() {
            const now = new Date();
            const timeLeft = targetDate - now;
            
            if (timeLeft <= 0) {
            clearInterval(timer);
            countdownElement.textContent = "Race started!";
            if (typeof onEnd === "function") {
                onEnd();
            }
            return;
            }
            
            const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
            
            let countdownStr = "";
            if (days > 0) {
            countdownStr += `${days}d `;
            }
            countdownStr += `${hours}h ${minutes}m ${seconds}s`;
            
            countdownElement.textContent = countdownStr;
        }
        
        updateCountdown();
        timer = setInterval(updateCountdown, 1000);
        }

                
                // Fetch the form status from form_details table
        async function fetchFormStatus() {
            try {
                const { data: formDetails, error: formDetailsError } = await supabase
                    .from('form_details')
                    .select('form_enabled')
                    .eq('id', 1)
                    .single();

                if (formDetailsError) {
                    console.error('Error fetching form status:', formDetailsError);
                    return false;
                }

                return formDetails.form_enabled;
            } catch (error) {
                console.error('Error fetching form status:', error);
                return false;
            }
        }

        // Update the latest form button based on form status and race start time
        async function updateFormButtonStatus(raceDetails) {
        const formEnabled = await fetchFormStatus();
        const formButton = document.getElementById('latest-form-button');

        // If raceDetails is available, determine if the race has started.
        if (raceDetails) {
            const raceStart = new Date(raceDetails.date);
            const raceHasStarted = new Date() >= raceStart;
            // Disable the button if the form is not enabled or if the race has started.
            if (!formEnabled || raceHasStarted) {
            formButton.disabled = true;
            return;
            }
        }
        // Otherwise, enable the button (if formEnabled is true).
        formButton.disabled = !formEnabled;
        }

        document.addEventListener('DOMContentLoaded', async () => {
        // Fetch race details
        const raceDetails = await fetchRaceDetails();

        // Update the latest form button with the current race name
        await updateLatestFormButton(raceDetails);

        // Update the next race info and initialize the countdown
        await updateNextRaceInfo(raceDetails);

        // Update the form button status based on form_enabled and race start
        await updateFormButtonStatus(raceDetails);

        // Add event listener to the form button
        const formButton = document.getElementById('latest-form-button');
        const formLink = document.getElementById('latest-form-link');

        formButton.addEventListener('click', (event) => {
            if (formButton.disabled) {
            event.preventDefault();
            } else {
            formLink.href = '/form';
            }
        });
        });


// RESULTS DISPLAY CODE
        document.addEventListener("DOMContentLoaded", async () => {
            document.getElementById('loadingPlaceholderBar').style.display = 'block';
            // ----- INITIAL DATA FETCHING -----

            // Fetch initial form details
            const { data: formDetails, error: formDetailsError } = await supabase
                .from('form_details')
                .select('*')
                .eq('id', 1)
                .single();

            if (formDetailsError) {
                console.error('Error fetching form details:', formDetailsError.message);
                return;
            }

            const { results_display_race_number, results_display_type, current_year } = formDetails;

            // Fetch the entire form configuration.
            // Each row represents one question. (e.g., id, text, response_type, enabled, etc.)
            const { data: formConfiguration, error: formConfigurationError } = await supabase
                .from('form_configuration')
                .select('*');
            if (formConfigurationError) {
                console.error('Error fetching form configuration:', formConfigurationError.message);
                return;
            }

            // Fetch race details
            const { data: raceDetails, error: raceDetailsError } = await supabase
                .from('calendar')
                .select('*')
                .eq('race_number', results_display_race_number)
                .single();

            if (raceDetailsError) {
                console.error('Error fetching race details:', raceDetailsError.message);
                return;
            }
            const raceName = `${raceDetails.name} GP`;

            // Fetch drivers and constructors
            const { data: drivers, error: driversError } = await supabase
                .from('drivers')
                .select('*');
            if (driversError) {
                console.error('Error fetching drivers:', driversError.message);
                return;
            }

            const { data: constructors, error: constructorsError } = await supabase
                .from('constructors')
                .select('*');
            if (constructorsError) {
                console.error('Error fetching constructors:', constructorsError.message);
                return;
            }

            // ----- ADDITIONAL TABLE FETCHES -----
            // Download the full players table (used for lookups in the conversion function)
            const { data: playersTable, error: playersTableError } = await supabase
                .from('players')
                .select('*');
            if (playersTableError) {
                console.error('Error fetching players table:', playersTableError.message);
                return;
            }

            // ----- UNORSCED PREDICTIONS SECTION -----
            if (results_display_type === 'Unscored Predictions') {
                // Show/hide appropriate sections
                document.getElementById('unscoredPredictions').style.display = 'block';
                document.getElementById('scoredResults').style.display = 'none';
                document.getElementById('noDisplay').style.display = 'none';

                // Set race title
                document.getElementById('unscoredRaceTitle').textContent = `${raceName} ${current_year} - Predictions`;

                // Show loading indicator for Unscored Predictions
                document.getElementById('loadingPlaceholderBar').style.display = 'none'; // Hide Placeholder Bar
                document.getElementById('unscoredLoading').style.display = 'block';

                // Fetch form responses from form_raw for the current race
                const { data: formResponses, error: formResponsesError } = await supabase
                    .from('form_raw')
                    .select('*')
                    .eq('race_number', results_display_race_number);
                if (formResponsesError) {
                    console.error('Error fetching form responses:', formResponsesError.message);
                    return;
                }

                // Filter out responses with player_id = 0 (only valid responses)
                const formResponsePlayers = formResponses.filter(response => response.player_id !== 0);

                // --- Define the Conversion Function ---
                function convertResponseToText(response, responseType) {
                    if (response === null || response === undefined) return '';
                    switch (responseType) {
                        case 'Select - Name List':
                            return playersTable.find(player => player.id === parseInt(response))?.name || response;
                        case 'Select - Driver List':
                        case 'Select - Driver List + DNF':
                            if (response === 'no-dnf') {
                                return 'No DNFs';
                            }
                            return drivers.find(driver => driver.id === parseInt(response))?.abbreviation || response;
                        case 'Select - Team List':
                            return constructors.find(constructor => constructor.id === parseInt(response))?.name || response;
                        case 'Radio - Yes/No':
                            return response.toLowerCase() === 'yes' ? 'Yes' : 'No';
                        case 'Radio - Heads/Tails':
                            return response.toLowerCase() === 'heads' ? 'Heads' : 'Tails';
                        default:
                            return response;
                    }
                }

                // --- Build the Table Header ---
                const headerRow = document.createElement('tr');
                headerRow.classList.add('header');
                headerRow.innerHTML = '<th>Name</th>';
                formResponsePlayers.forEach(response => {
                    const player = playersTable.find(p => p.id === response.player_id);
                    const th = document.createElement('th');
                    th.textContent = player?.name || response.player_name || 'Unknown';
                    headerRow.appendChild(th);
                });
                document.getElementById('unscoredTableHeader').appendChild(headerRow);

                // --- Build the Table Body ---
                const tableBody = document.getElementById('unscoredTableBody');
                formConfiguration.forEach(question => {
                    // Only process enabled questions.
                    if (!question.enabled) return;
                    // Skip the question used for the "Name" column (assumed to be id === 1)
                    if (question.id === 1) return;

                    const row = document.createElement('tr');
                    // First cell: the question text
                    row.innerHTML = `<td>${question.text}</td>`;
                    // For each player's response, add a cell.
                    formResponsePlayers.forEach(response => {
                        const td = document.createElement('td');
                        const rawResponse = response[`form_id_${question.id}`];
                        td.textContent = convertResponseToText(rawResponse, question.response_type);
                        row.appendChild(td);
                    });
                    tableBody.appendChild(row);
                });

                // --- Apply Formatting ---
                const applyFormatting = (cell, value) => {
                    if (/^[A-Z]{3}$/.test(value)) {
                        const driver = drivers.find(driver => driver.abbreviation === value);
                        if (driver) {
                            const constructor = constructors.find(constructor => constructor.id === driver.constructor_id);
                            if (constructor) {
                                cell.style.backgroundColor = constructor.background_colour;
                                cell.style.color = constructor.text_colour;
                            }
                        }
                    } else if (/^\d+$/.test(value)) {
                        // Numeric values: no additional formatting.
                    } else if (value === 'Yes') {
                        cell.style.color = 'green';
                        cell.style.backgroundColor = 'white';
                    } else if (value === 'No') {
                        cell.style.color = 'red';
                        cell.style.backgroundColor = 'white';
                    } else {
                        const constructor = constructors.find(constructor => constructor.name === value);
                        if (constructor) {
                            cell.style.backgroundColor = constructor.background_colour;
                            cell.style.color = constructor.text_colour;
                        }
                    }
                };

                document.querySelectorAll('#unscoredTableBody td').forEach(cell => {
                    applyFormatting(cell, cell.textContent);
                });

                // Hide the loading indicator after the unscored table has been built.
                document.getElementById('unscoredLoading').style.display = 'none';

            // --- Scored Results Section Begins ---
            } else if (results_display_type === 'Scored Results') { 
                document.getElementById('unscoredPredictions').style.display = 'none';
                document.getElementById('scoredResults').style.display = 'block';
                document.getElementById('noDisplay').style.display = 'none';

                // Set race title
                document.getElementById('raceTitle').textContent = `${raceName} ${current_year} - Results`;

                // Show loading indicator for Scored Results
                document.getElementById('loadingPlaceholderBar').style.display = 'none'; // Hide Placeholder Bar
                document.getElementById('scoredLoading').style.display = 'block';

                // Fetch form responses from form_responses_{current_year}
                const { data: formResponses, error: formResponsesError } = await supabase
                    .from(`form_responses_${current_year}`)
                    .select('*')
                    .eq('race_number', results_display_race_number);
                if (formResponsesError) {
                    console.error('Error fetching form responses:', formResponsesError.message);
                    return;
                }

                // Process form responses
                const questions = formResponses.find(response => response.entry_type === 'questions');
                const results = formResponses.find(response => response.entry_type === 'results');
                //console.log('Results object:', results);
                const players = formResponses.filter(response => response.entry_type === 'player');
                const lowestScores = formResponses.filter(response => response.entry_type === 'player_lowest_score');

                // Create header row for scored results
                const headerRow = document.createElement('tr');
                headerRow.classList.add('header');
                headerRow.innerHTML = '<th>Name</th>';
                players.forEach(player => {
                    const th = document.createElement('th');
                    th.textContent = player.player_name;
                    headerRow.appendChild(th);
                });
                headerRow.innerHTML += '<th style="background-color: white; border-top: none; border-bottom: none;"></th><th>Results</th>';
                document.getElementById('tableHeader').appendChild(headerRow);

                // Create data rows for scored results
                const tableBody = document.getElementById('tableBody');
                const createRow = (id, label) => {
                    //console.log(`Creating row for ID: ${id}, Label: ${label}`);
                    const isTotalColumn = ['subtotal_1', 'subtotal_2', 'subtotal_3', 'subtotal_4', 'grand_total'].includes(id);
                    if (isTotalColumn) {
                        //console.log(`Checking total column: ${id}`);
                        const row = document.createElement('tr');
                        row.innerHTML = `<td>${label}</td>`;
                        players.forEach(player => {
                            //console.log(`Processing player: ${player.player_name}, Player ID: ${player.player_id}`);
                            const td = document.createElement('td');
                            td.textContent = player[id];
                            //console.log(`Player ${player.player_name} score for ${id}: ${player[id]}`);
                            td.className = `${id}_score`;
                            td.dataset.playerId = player.player_id;
                            row.appendChild(td);
                        });
                        row.innerHTML += `<td style="background-color: white;"></td><td></td>`;
                        //console.log(`Appending row: ${row.innerHTML}`);
                        tableBody.appendChild(row);
                    } else {
                        //console.log(`Checking form_id column: form_id_${id}`);
                        if (results[`form_id_${id}`] !== null) {
                            //console.log(`Results for form_id_${id}: ${results[`form_id_${id}`]}`);
                            const row = document.createElement('tr');
                            row.innerHTML = `<td>${label}</td>`;
                            players.forEach(player => {
                                //console.log(`Processing player: ${player.player_name}, Player ID: ${player.player_id}`);
                                const td = document.createElement('td');
                                td.textContent = player[`form_id_${id}`];
                                //console.log(`Player ${player.player_name} score for form_id_${id}: ${player[`form_id_${id}`]}`);
                                td.className = `form_id_${id}_score`;
                                td.dataset.playerId = player.player_id;
                                row.appendChild(td);
                            });
                            row.innerHTML += `<td style="background-color: white;"></td><td>${results[`form_id_${id}`]}</td>`;
                            //console.log(`Appending row: ${row.innerHTML}`);
                            tableBody.appendChild(row);
                        } else {
                            //console.log(`No results found for form_id_${id}`);
                        }
                    }
                };

                // Add question rows for scored results
                for (let i = 2; i <= 7; i++) {
                    createRow(i, questions[`form_id_${i}`]);
                }
                createRow('subtotal_2', 'Subtotal');
                tableBody.innerHTML += '<tr class="spacer-row"><td colspan="100%" style="background-color: white;"></td></tr>';
                for (let i = 8; i <= 27; i++) {
                    createRow(i, questions[`form_id_${i}`]);
                }
                createRow('subtotal_3', 'Subtotal');
                tableBody.innerHTML += '<tr class="spacer-row"><td colspan="100%" style="background-color: white;"></td></tr>';
                createRow(28, questions[`form_id_28`]);
                tableBody.innerHTML += '<tr class="spacer-row"><td colspan="100%" style="background-color: white;"></td></tr>';
                createRow('grand_total', 'Grand Total');

                // Apply formatting for scored results
                const applyFormattingScored = (cell, value) => {
                    if (/^[A-Z]{3}$/.test(value)) {
                        const driver = drivers.find(driver => driver.abbreviation === value);
                        if (driver) {
                            const constructor = constructors.find(constructor => constructor.id === driver.constructor_id);
                            if (constructor) {
                                cell.style.backgroundColor = constructor.background_colour;
                                cell.style.color = constructor.text_colour;
                            }
                        }
                    } else if (/^\d+$/.test(value)) {
                        // No additional formatting for numeric values.
                    } else if (value === 'Yes') {
                        cell.style.color = 'green';
                        cell.style.backgroundColor = 'white';
                    } else if (value === 'No') {
                        cell.style.color = 'red';
                        cell.style.backgroundColor = 'white';
                    } else {
                        const constructor = constructors.find(constructor => constructor.name === value);
                        if (constructor) {
                            cell.style.backgroundColor = constructor.background_colour;
                            cell.style.color = constructor.text_colour;
                        }
                    }
                };

                document.querySelectorAll('#mainResultsTable tbody td').forEach(cell => {
                    applyFormattingScored(cell, cell.textContent);
                });

                // Highlight highest scores, closest scores, and display top scorers
                const highlightHighest = (selector, colors) => {
                    const cells = Array.from(document.querySelectorAll(selector));
                    const values = cells.map(cell => parseFloat(cell.textContent)).filter(value => !isNaN(value));
                    const sortedValues = [...new Set(values)].sort((a, b) => b - a);
                    cells.forEach(cell => {
                        const cellValue = parseFloat(cell.textContent);
                        const rank = sortedValues.indexOf(cellValue);
                        if (rank >= 0 && rank < colors.length) {
                            cell.style.backgroundColor = colors[rank];
                            cell.style.color = 'black';
                        }
                    });
                };

                const highlightClosestScore = (selector, color) => {
                    const cells = Array.from(document.querySelectorAll(selector));
                    cells.forEach(cell => {
                        const playerId = cell.dataset.playerId;
                        const player = players.find(player => player.player_id == playerId);
                        const playerScore = player ? player.form_id_28_score : null;
                        if (playerScore === 1) {
                            cell.style.backgroundColor = color;
                            cell.style.color = 'black';
                        } else {
                            cell.style.backgroundColor = '';
                            cell.style.color = '';
                        }
                    });
                };

                highlightHighest('td.subtotal_2_score', ['lightyellow']);
                highlightHighest('td.subtotal_3_score', ['lightyellow']);
                highlightHighest('td.grand_total_score', ['gold', 'silver', '#cd7f32']);
                highlightClosestScore('td.form_id_28_score', 'lightyellow');

                const grandTotals = players.map(player => ({
                    name: player.player_name,
                    total: parseFloat(player.grand_total)
                })).sort((a, b) => b.total - a.total);
                document.getElementById('firstPlace').textContent = grandTotals[0]?.name || '';
                document.getElementById('secondPlace').textContent = grandTotals[1]?.name || '';
                document.getElementById('thirdPlace').textContent = grandTotals[2]?.name || '';

                document.getElementById('toggleScores').addEventListener('change', (event) => {
                    const showScores = event.target.checked;
                    document.querySelectorAll('#mainResultsTable tbody td').forEach(cell => {
                        const idMatch = cell.className.match(/form_id_(\d+)_score/);
                        if (idMatch) {
                            const scoreId = `form_id_${idMatch[1]}_score`;
                            const playerId = cell.dataset.playerId;
                            const player = players.find(player => player.player_id == playerId);
                            const playerScore = player ? player[scoreId] : null;
                            if (playerScore !== null) {
                                cell.textContent = showScores ? `${cell.textContent} (${playerScore})` : cell.textContent.split(' ')[0];
                            }
                        }
                    });
                });

                const lowestScoresDiv = document.getElementById('lowestScores');
                if (lowestScores.length > 0) {
                    const lowestScoresText = lowestScores.map(player => player.player_name).join(', ');
                    lowestScoresDiv.textContent = `Lowest Score: ${lowestScoresText}`;
                }

                // Hide the loading indicator after the scored results table is built.
                document.getElementById('scoredLoading').style.display = 'none';
            } else if (results_display_type === 'No Display') {
                document.getElementById('loadingPlaceholderBar').style.display = 'none'; // Hide Placeholder Bar
                document.getElementById('unscoredPredictions').style.display = 'none';
                document.getElementById('scoredResults').style.display = 'none';
                document.getElementById('noDisplay').style.display = 'block';
            }
        });

// --- Player Standings Tables ---
        async function getTable(tableName) {
        const { data, error } = await supabase.from(tableName).select('*');
        if (error) {
            console.error(`Error fetching ${tableName}:`, error);
            throw error;
        }
        return data;
        }

        async function loadHomeStandings() {
        try {
            // 1. Retrieve the current year from form_details.
            const formDetails = await getTable('form_details');
            if (!formDetails || formDetails.length === 0) {
            console.error("No form_details found.");
            return;
            }
            const currentYear = formDetails[0].current_year;
            //console.log("Current Year:", currentYear);

            // 2. Retrieve the full season_player_{year} table.
            const seasonTableName = `season_player_${currentYear}`;
            const seasonData = await getTable(seasonTableName);
            //console.log("Season Data:", seasonData);

            if (!seasonData || seasonData.length === 0) {
            document.querySelector("#standings-table tbody").innerHTML =
                "<tr><td colspan='3'>No season data available.</td></tr>";
            return;
            }

            // 3. Exclude the special "Race Names" row (player_id === 0).
            const playerRows = seasonData.filter(row => row.player_id !== 0);
            if (playerRows.length === 0) {
            document.querySelector("#standings-table tbody").innerHTML =
                "<tr><td colspan='3'>No player data available.</td></tr>";
            return;
            }

            // 4. Determine the last race that has been scored.
            let lastRace = 0;
            const raceNamesRow = seasonData.find(row => row.player_id === 0);
            if (raceNamesRow) {
            // Assume columns are named race_1, race_2, ..., race_32.
            for (let i = 1; i <= 32; i++) {
                const col = `race_${i}`;
                if (raceNamesRow[col] !== null && raceNamesRow[col] !== "") {
                lastRace = i;
                } else {
                break;
                }
            }
            }
            //console.log("Last race with data:", lastRace);
            if (lastRace === 0) {
            document.querySelector("#standings-table tbody").innerHTML =
                "<tr><td colspan='3'>No race scores available yet.</td></tr>";
            return;
            }

            // 5. Compute current total scores (summing races 1 to lastRace) for each player.
            const standings = playerRows.map(row => {
            let total = 0;
            let prevTotal = 0;
            for (let i = 1; i <= lastRace; i++) {
                const col = `race_${i}`;
                const rawVal = row[col];
                if (rawVal !== null && rawVal !== "") {
                // Remove any "(LS)" suffix and trim.
                const numStr = rawVal.replace(/\(LS\)/, "").trim();
                const num = parseFloat(numStr);
                if (!isNaN(num)) {
                    total += num;
                    if (i < lastRace) {
                    prevTotal += num;
                    }
                }
                }
            }
            return {
                player_id: row.player_id,
                player_name: row.player_name,
                total: total,
                prevTotal: prevTotal
            };
            });

            // 6. Sort standings descending by current total score.
            standings.sort((a, b) => b.total - a.total);

            // 7. Assign current ranks with ties receiving the same rank.
            let currentRank = 1;
            let prevScore = null;
            const currentRankMap = {};
            standings.forEach((player, index) => {
            if (prevScore === null || player.total !== prevScore) {
                currentRank = index + 1;
            }
            currentRankMap[player.player_id] = currentRank;
            prevScore = player.total;
            });

            // 8. Compute previous standings if lastRace > 1.
            const prevRankMap = {};
            if (lastRace > 1) {
            const prevStandings = [...standings].sort((a, b) => b.prevTotal - a.prevTotal);
            let prevRank = 1;
            let prevPrevScore = null;
            prevStandings.forEach((player, index) => {
                if (prevPrevScore === null || player.prevTotal !== prevPrevScore) {
                prevRank = index + 1;
                }
                prevRankMap[player.player_id] = prevRank;
                prevPrevScore = player.prevTotal;
            });
            }

            // 9. Build HTML rows.
            let html = "";
            standings.forEach(player => {
            const currRank = currentRankMap[player.player_id];
            let movement = "";
            if (lastRace > 1 && prevRankMap[player.player_id] !== undefined) {
                const diff = prevRankMap[player.player_id] - currRank;
                if (diff > 0) {
                movement = `(+${diff})`;
                } else if (diff < 0) {
                movement = `(${diff})`;
                } else {
                movement = "(=)";
                }
            }
            html += `<tr>
                        <td>${currRank} ${movement}</td>
                        <td>${player.player_name}</td>
                        <td>${player.total}</td>
                    </tr>`;
            });
            document.querySelector("#standings-table tbody").innerHTML = html;
        } catch (err) {
            console.error("loadHomeStandings error:", err);
            document.querySelector("#standings-table tbody").innerHTML =
            `<tr><td colspan="3">Error loading standings: ${err.message}</td></tr>`;
        }
        }

        document.addEventListener("DOMContentLoaded", () => {
        loadHomeStandings();
        });

// --- Season Team Standings ---
// --- Team Standings for Home Page ---
        async function loadHomeTeamStandings() {
        try {
            // 1. Retrieve the current year from form_details.
            const formDetails = await getTable('form_details');
            if (!formDetails || formDetails.length === 0) {
            console.error("No form_details found.");
            return;
            }
            const currentYear = formDetails[0].current_year;
            //console.log("Current Year:", currentYear);

            // 2. Retrieve the full season_team_{year} table.
            const seasonTeamTable = `season_team_${currentYear}`;
            const seasonTeamData = await getTable(seasonTeamTable);
            //console.log("Season Team Data:", seasonTeamData);

            if (!seasonTeamData || seasonTeamData.length === 0) {
            document.querySelector("#standings-team-table tbody").innerHTML =
                "<tr><td colspan='3'>No season team data available.</td></tr>";
            return;
            }

            // 3. Exclude the special "Race Names" row (team_id === 0).
            const teamRows = seasonTeamData.filter(row => row.team_id !== 0);
            if (teamRows.length === 0) {
            document.querySelector("#standings-team-table tbody").innerHTML =
                "<tr><td colspan='3'>No team data available.</td></tr>";
            return;
            }

            // 4. Determine the last race that has been scored using the Race Names row.
            let lastRace = 0;
            const raceNamesRow = seasonTeamData.find(row => row.team_id === 0);
            if (raceNamesRow) {
            // Assume race columns are named race_1, race_2, ..., race_32.
            for (let i = 1; i <= 32; i++) {
                const col = `race_${i}`;
                if (raceNamesRow[col] !== null && raceNamesRow[col] !== "") {
                lastRace = i;
                } else {
                break;
                }
            }
            }
            //console.log("Last race with data:", lastRace);
            if (lastRace === 0) {
            document.querySelector("#standings-team-table tbody").innerHTML =
                "<tr><td colspan='3'>No race scores available yet.</td></tr>";
            return;
            }

            // 5. Compute current total scores (summing races 1 to lastRace) for each team.
            //    We strip any extra tags (e.g. "(double)") using a regex that removes text within parentheses.
            const standings = teamRows.map(row => {
            let total = 0;
            let prevTotal = 0;
            for (let i = 1; i <= lastRace; i++) {
                const col = `race_${i}`;
                const rawVal = row[col];
                if (rawVal !== null && rawVal !== "") {
                // Remove any tags such as "(double)" or "(aero)".
                const numStr = rawVal.replace(/\(.*?\)/g, "").trim();
                const num = parseFloat(numStr);
                if (!isNaN(num)) {
                    total += num;
                    if (i < lastRace) {
                    prevTotal += num;
                    }
                }
                }
            }
            return {
                team_id: row.team_id,
                team_name: row.team_name,
                total: total,
                prevTotal: prevTotal
            };
            });

            // 6. Sort standings descending by current total score.
            standings.sort((a, b) => b.total - a.total);

            // 7. Assign current ranks with ties receiving the same rank.
            let currentRank = 1;
            let prevScore = null;
            const currentRankMap = {};
            standings.forEach((team, index) => {
            if (prevScore === null || team.total !== prevScore) {
                currentRank = index + 1;
            }
            currentRankMap[team.team_id] = currentRank;
            prevScore = team.total;
            });

            // 8. Compute previous standings if lastRace > 1.
            const prevRankMap = {};
            if (lastRace > 1) {
            // Create a copy and sort by the total up to race lastRace-1.
            const prevStandings = [...standings].sort((a, b) => b.prevTotal - a.prevTotal);
            let prevRank = 1;
            let prevPrevScore = null;
            prevStandings.forEach((team, index) => {
                if (prevPrevScore === null || team.prevTotal !== prevPrevScore) {
                prevRank = index + 1;
                }
                prevRankMap[team.team_id] = prevRank;
                prevPrevScore = team.prevTotal;
            });
            }

            // 9. Build HTML rows for each team.
            let html = "";
            standings.forEach(team => {
            const currRank = currentRankMap[team.team_id];
            let movement = "";
            if (lastRace > 1 && prevRankMap[team.team_id] !== undefined) {
                const diff = prevRankMap[team.team_id] - currRank;
                if (diff > 0) {
                movement = `(+${diff})`;
                } else if (diff < 0) {
                movement = `(${diff})`;
                } else {
                movement = "(=)";
                }
            }
            html += `<tr>
                        <td>${currRank} ${movement}</td>
                        <td>${team.team_name}</td>
                        <td>${team.total}</td>
                    </tr>`;
            });
            document.querySelector("#standings-team-table tbody").innerHTML = html;
        } catch (err) {
            console.error("loadHomeTeamStandings error:", err);
            document.querySelector("#standings-team-table tbody").innerHTML =
            `<tr><td colspan="3">Error loading team standings: ${err.message}</td></tr>`;
        }
        }

        // --- Initialize Team Standings on DOMContentLoaded ---
        document.addEventListener("DOMContentLoaded", () => {
        loadHomeTeamStandings();
        });

        async function updateFormStatusText() {
  // Fetch the form details for id = 1 from Supabase
  const { data, error } = await supabase
    .from('form_details')
    .select('form_status_text, form_status_text_enabled')
    .eq('id', 1)
    .single();

  if (error) {
    console.error('Error fetching form details:', error);
    return;
  }

  // Select the HTML elements by their IDs
  const container = document.getElementById('formStatusContainer');
  const textElement = document.getElementById('formStatusText');

  // If enabled, update the text and show the container
  if (data.form_status_text_enabled) {
    textElement.textContent = data.form_status_text;
    container.style.display = 'block';
  } else {
    // Otherwise, ensure the container is hidden
    container.style.display = 'none';
  }
}

// Run the function when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', updateFormStatusText);

// --- CHART ---
async function renderStandingsLineChart() {
  try {
    // 1. Retrieve current year from form_details.
    const { data: formDetails, error: formDetailsError } = await supabase
      .from('form_details')
      .select('current_year')
      .eq('id', 1)
      .single();
    if (formDetailsError) {
      console.error('Error fetching form details:', formDetailsError);
      return;
    }
    const currentYear = formDetails.current_year;

    // 2. Retrieve season data.
    const seasonTableName = `season_player_${currentYear}`;
    const seasonData = await getTable(seasonTableName);
    if (!seasonData || seasonData.length === 0) {
      console.error("No season data available.");
      return;
    }

    // 3. Get race names from the row where player_id === 0.
    const raceNamesRow = seasonData.find(row => row.player_id === 0);
    if (!raceNamesRow) {
      console.error("No race names row found.");
      return;
    }
    let lastRace = 0;
    const raceLabels = [];
    for (let i = 1; i <= 32; i++) {
      const col = `race_${i}`;
      let raceName = raceNamesRow[col];
      if (raceName !== null && raceName !== "") {
        // Strip any "(LS)" suffix and trim.
        raceName = raceName.replace(/\(LS\)/g, "").trim();
        raceLabels.push(raceName);
        lastRace = i;
      } else {
        break;
      }
    }
    if (lastRace === 0) {
      console.error("No race names available.");
      return;
    }

    // 4. Filter out player rows (player_id !== 0).
    const playerRows = seasonData.filter(row => row.player_id !== 0);
    if (!playerRows.length) {
      console.error("No player data found.");
      return;
    }

    // 5. Compute cumulative scores for each player.
    const playerCumulativeScores = {};
    playerRows.forEach(player => {
      let cumulative = [];
      let sum = 0;
      for (let i = 1; i <= lastRace; i++) {
        const col = `race_${i}`;
        let scoreStr = player[col];
        if (scoreStr !== null && scoreStr !== "") {
          scoreStr = scoreStr.replace(/\(LS\)/g, "").trim();
          const score = parseFloat(scoreStr);
          if (!isNaN(score)) {
            sum += score;
          }
        }
        cumulative.push(sum);
      }
      playerCumulativeScores[player.player_id] = {
        player_name: player.player_name,
        cumulative: cumulative
      };
    });

    // 6. Compute rankings for each race.
    const playerRankings = {};
    playerRows.forEach(player => {
      playerRankings[player.player_id] = [];
    });
    for (let raceIndex = 0; raceIndex < lastRace; raceIndex++) {
      const scores = playerRows.map(player => ({
        player_id: player.player_id,
        score: playerCumulativeScores[player.player_id].cumulative[raceIndex]
      }));
      scores.sort((a, b) => b.score - a.score);
      let rank = 1;
      let prevScore = null;
      scores.forEach((item, index) => {
        if (prevScore === null || item.score !== prevScore) {
          rank = index + 1;
        }
        playerRankings[item.player_id].push(rank);
        prevScore = item.score;
      });
    }

    // 7. Build Chart.js datasets for each player.
    const datasets = [];
    const colors = [
      '#e6194b', '#3cb44b', '#ffe119', '#4363d8',
      '#f58231', '#911eb4', '#46f0f0', '#f032e6',
      '#bcf60c', '#fabebe', '#008080', '#e6beff',
      '#9a6324', '#fffac8', '#800000', '#aaffc3',
      '#808000', '#ffd8b1', '#000075', '#808080'
    ];
    let colorIndex = 0;
    playerRows.forEach(player => {
      datasets.push({
        label: player.player_name,
        data: playerRankings[player.player_id],
        fill: false,
        borderColor: colors[colorIndex % colors.length],
        backgroundColor: colors[colorIndex % colors.length],
        borderWidth: 4,              // Thick lines for pixel-art feel.
        tension: 0,                  // No smoothing.
        pointStyle: 'rect',          // Square markers.
        pointRadius: 5,
        pointHoverRadius: 7
      });
      colorIndex++;
    });
    
    // Sort datasets alphabetically by player name.
    datasets.sort((a, b) => a.label.localeCompare(b.label));
    
    // 8. Determine max rank (number of players) for y-axis.
    const maxRank = playerRows.length;

    // 9. Create the chart.
    const ctx = document.getElementById('standings-line-chart').getContext('2d');
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: raceLabels,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false, // Stops forced aspect ratio
        layout: {
            padding: 10,
        },
        onClick: (evt, activeEls) => {
          if (activeEls.length > 0) {
            const element = activeEls[0];
            const datasetIndex = element.datasetIndex;
            const playerName = datasets[datasetIndex].label;
          }
        },
        plugins: {
          title: {
            display: true,
            text: `Player Standings ${currentYear}`,
            color: 'black',
            font: {
              family: 'Pixeloid Sans Bold',
              size: 20,
            }
          },
          legend: {
            position: 'bottom',
            labels: {
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            }
          }
        },
        scales: {
          y: {
            reverse: true,    // So that rank 1 is at the top.
            min: 1,
            max: maxRank,
            offset: true,     // Extra space so the top line isnt cut off.
            ticks: {
              stepSize: 1,
              padding: 10,
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            },
            title: {
              display: true,
              text: 'Rank',
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            }
          },
          x: {
            ticks: {
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            },
            title: {
              display: false  // No x-axis label.
            }
          }
        },
        layout: {
          padding: {
            top: 20,
            bottom: 20,
            left: 10,
            right: 10
          }
        }
      }
    });
  } catch (err) {
    console.error("Error rendering the standings chart:", err);
  }
}



// --- TEAM STANDINGS CHART ---
async function renderTeamStandingsLineChart() {
  try {
    // 1. Retrieve current year from form_details.
    const { data: formDetails, error: formDetailsError } = await supabase
      .from('form_details')
      .select('current_year')
      .eq('id', 1)
      .single();
    if (formDetailsError) {
      console.error('Error fetching form details:', formDetailsError);
      return;
    }
    const currentYear = formDetails.current_year;

    // 2. Retrieve season team data.
    const seasonTeamTableName = `season_team_${currentYear}`;
    const seasonTeamData = await getTable(seasonTeamTableName);
    if (!seasonTeamData || seasonTeamData.length === 0) {
      console.error("No season team data available.");
      return;
    }

    // 3. Get race names from the row where team_id === 0.
    const raceNamesRow = seasonTeamData.find(row => row.team_id === 0);
    if (!raceNamesRow) {
      console.error("No race names row found for teams.");
      return;
    }
    let lastRace = 0;
    const raceLabels = [];
    for (let i = 1; i <= 32; i++) {
      const col = `race_${i}`;
      let raceName = raceNamesRow[col];
      if (raceName !== null && raceName !== "") {
        // Remove any tags (e.g. "(double)" or similar) and trim.
        raceName = raceName.replace(/\(.*?\)/g, "").trim();
        raceLabels.push(raceName);
        lastRace = i;
      } else {
        break;
      }
    }
    if (lastRace === 0) {
      console.error("No race names available for teams.");
      return;
    }

    // 4. Filter out the team rows (team_id !== 0).
    const teamRows = seasonTeamData.filter(row => row.team_id !== 0);
    if (!teamRows.length) {
      console.error("No team data found.");
      return;
    }

    // 5. Compute cumulative scores for each team.
    const teamCumulativeScores = {};
    teamRows.forEach(team => {
      let cumulative = [];
      let sum = 0;
      for (let i = 1; i <= lastRace; i++) {
        const col = `race_${i}`;
        let scoreStr = team[col];
        if (scoreStr !== null && scoreStr !== "") {
          // Remove any tags such as "(double)".
          scoreStr = scoreStr.replace(/\(.*?\)/g, "").trim();
          const score = parseFloat(scoreStr);
          if (!isNaN(score)) {
            sum += score;
          }
        }
        cumulative.push(sum);
      }
      teamCumulativeScores[team.team_id] = {
        team_name: team.team_name,
        cumulative: cumulative
      };
    });

    // 6. Compute rankings for each race.
    const teamRankings = {};
    teamRows.forEach(team => {
      teamRankings[team.team_id] = [];
    });
    for (let raceIndex = 0; raceIndex < lastRace; raceIndex++) {
      const scores = teamRows.map(team => ({
        team_id: team.team_id,
        score: teamCumulativeScores[team.team_id].cumulative[raceIndex]
      }));
      scores.sort((a, b) => b.score - a.score);
      let rank = 1;
      let prevScore = null;
      scores.forEach((item, index) => {
        if (prevScore === null || item.score !== prevScore) {
          rank = index + 1;
        }
        teamRankings[item.team_id].push(rank);
        prevScore = item.score;
      });
    }

    // 7. Build Chart.js datasets for each team.
    const datasets = [];
    const colors = [
      '#e6194b', '#3cb44b', '#ffe119', '#4363d8',
      '#f58231', '#911eb4', '#46f0f0', '#f032e6',
      '#bcf60c', '#fabebe', '#008080', '#e6beff',
      '#9a6324', '#fffac8', '#800000', '#aaffc3',
      '#808000', '#ffd8b1', '#000075', '#808080'
    ];
    let colorIndex = 0;
    teamRows.forEach(team => {
      datasets.push({
        label: team.team_name,
        data: teamRankings[team.team_id],
        fill: false,
        borderColor: colors[colorIndex % colors.length],
        backgroundColor: colors[colorIndex % colors.length],
        borderWidth: 4,              // Thick lines for a pixel-art feel.
        tension: 0,                  // No smoothing.
        pointStyle: 'rect',          // Square markers.
        pointRadius: 5,
        pointHoverRadius: 7
      });
      colorIndex++;
    });
    
    // Sort datasets alphabetically by team name.
    datasets.sort((a, b) => a.label.localeCompare(b.label));
    
    // 8. Determine max rank (number of teams) for y-axis.
    const maxRank = teamRows.length;

    // 9. Create the chart.
    const ctx = document.getElementById('standings-team-line-chart').getContext('2d');
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: raceLabels,
        datasets: datasets
      },
      options: {
        responsive: true,
        maintainAspectRatio: false, // Allow flexible sizing.
        layout: {
          padding: 10,
        },
        plugins: {
          title: {
            display: true,
            text: `Team Standings ${currentYear}`,
            color: 'black',
            font: {
                family: 'Pixeloid Sans Bold',
                size: 20,
            }
          },
          legend: {
            position: 'bottom',
            labels: {
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            }
          }
        },
        scales: {
          y: {
            reverse: true,    // Rank 1 at the top.
            min: 1,
            max: maxRank,
            offset: true,     // Extra space so the top line isnt cut off.
            ticks: {
              stepSize: 1,
              padding: 10,
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            },
            title: {
              display: true,
              text: 'Rank',
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            }
          },
          x: {
            ticks: {
              font: {
                family: 'Pixeloid Sans'
              },
              color: 'black'
            },
            title: {
              display: false  // No x-axis label.
            }
          }
        },
        layout: {
          padding: {
            top: 20,
            bottom: 20,
            left: 10,
            right: 10
          }
        }
      }
    });
  } catch (err) {
    console.error("Error rendering the team standings chart:", err);
  }
}

document.addEventListener("DOMContentLoaded", () => {
    renderStandingsLineChart();
  renderTeamStandingsLineChart();
});

    </script>

</body>
</html>