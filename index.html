<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1 Predictions</title>
    <link rel="icon" href="/media/f1_predictions_logo.ico" type="image/x-icon">
    <!-- Bootstrap CSS (Local) -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/style.css">
    <style> 
        /* Container for the image and overlay */
        .full-width-image-container {
            position: relative; /* Allows for absolute positioning of overlay */
            width: 100%;        /* Full width of the container */
            height: 180px;      /* Fixed height for the image */
            overflow: hidden;   /* Prevents anything from overflowing */
        }

        /* Image styling */
        .full-width-image {
            width: 100%;        /* Full width of the container */
            height: 100%;       /* Full height of the container */
            object-fit: cover;  /* Ensures the image scales proportionally and fills the container */
        }

        /* Transparent overlay styling */
        .overlay {
            position: absolute;   /* Positioned relative to the parent container */
            top: 0;               /* Start at the top of the container */
            left: 0;              /* Start at the left of the container */
            width: 100%;          /* Full width of the container */
            height: 100%;         /* Full height of the container (200px) */
            background-color: rgba(0, 0, 0, 0.4); /* Transparent black overlay */
        }
    </style>
        <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
    <script>
        // Initialize Supabase globally
        const supabaseUrl = 'https://mbyhlefxnjjzmiwsvnaa.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ieWhsZWZ4bmpqem1pd3N2bmFhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzQzODQwOTgsImV4cCI6MjA0OTk2MDA5OH0.4gcUcOfhyTspbcDn6gPxBKFSTu3zUbkBdNEhMq9MdnY';
        var supabase = supabase.createClient(supabaseUrl, supabaseKey);
    </script>
</head>
<body>
    <header class="bg-light text-black py-2.5 d-flex align-items-center justify-content-between sticky-top">
        <!-- Left Section: Logo and Heading -->
        <div class="d-flex align-items-center">
            <a href="/" class="ms-2.5 me-2 d-flex align-items-center">
                <img src="/media/f1_predictions_logo.png" alt="Logo" style="height: 45px;">
            </a>
            <a href="/" class="text-decoration-none text-black">
                <h5 class="mb-0 pixel-art-heading-2">F1 Predictions</h5>
            </a>
        </div>
        
        <!-- Right Section: Hamburger Menu -->
        <div class="pixel-dropdown me-3">
            <button class="pixel-button" type="button" id="hamburgerMenu" data-bs-toggle="dropdown" aria-expanded="false">
                Menu
            </button>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="hamburgerMenu">
                <li><a class="dropdown-item pixel-art-body-smallx" href="/">Home</a></li>
                <li><hr class="dropdown-divider"></li> <!-- Spacer -->
                <li><a class="dropdown-item pixel-art-body-smallx" href="/form">Form</a></li>
                <li><a class="dropdown-item pixel-art-body-smallx" href="/teams">Teams</a></li>
                <li><a class="dropdown-item pixel-art-body-smallx" href="/results">Results</a></li>
                <li><a class="dropdown-item pixel-art-body-smallx" href="/register">Register</a></li>
                <li><a class="dropdown-item pixel-art-body-smallx" href="/feedback">Feedback</a></li>
                <li><a class="dropdown-item pixel-art-body-smallx" href="/info">Info</a></li>
                <li><a class="dropdown-item pixel-art-body-smallx" href="/archive">Archive</a></li>
                <li><hr class="dropdown-divider"></li> <!-- Spacer -->
                <li><a class="dropdown-item pixel-art-body-smallx" href="/admin">Admin</a></li>
            </ul>
        </div>
    </header>    

    <!-- Full-Width Image Section with Centered Text -->
<section class="full-width-image-container">
    <img src="/media/ferrari_background.png" alt="Full Width Image" class="full-width-image">
    <div class="overlay"></div> <!-- Transparent black layer -->

    <!-- Centered Text -->
    <h2  class="centered-text-pixel-art-heading">F1 Predictions Form</h2>
</section>

    <main class="container my-5">
        <div class="row g-4">
            <!-- Left Column: Latest Form -->
            <div class="col-md-6">
                <div class="text-center">
                    <h5 class="mb-3 pixel-art-body">Latest Form:</h5>
                    <a id="latest-form-link">
                        <button id="latest-form-button" type="button" class="pixel-button" disabled>Loading...</button>
                    </a>
                </div>
            </div>
    
        <!-- Right Column: Quick Links -->
        <div class="col-md-6">
            <div class="text-center">
                <h5 class="mb-3 pixel-art-body">Quick Links:</h5>
                <!-- Changed to flex-row for horizontal alignment -->
                <div class="d-flex flex-row justify-content-center gap-3">
                    <a href="/results">
                        <button type="button" class="pixel-button">Results</button>
                    </a>
                    <a href="/teams">
                        <button type="button" class="pixel-button">Teams</button>
                    </a>
                </div>
            </div>
        </div>

        </div>
    
        <!-- Next Race Section -->
<!-- Next Race Section -->
<div class="text-center mt-5">
    <h5 class="pixel-art-body">Next Race:</h5>
    <div id="next-race-info" class="mt-3">
        <p class="pixel-art-body-small">Loading next race...</p>
    </div>
    <!-- Removed the separate #countdown-timer container -->
</div>
<hr>
<!-- Scored Results Section -->
<div id="scoredResults" style="display: none;"> <!-- Scored Results Placeholder -->
    <div class="container my-3 d-flex justify-content-left">
        <h4 class="mb-3 pixel-art-heading-3">Latest Results</h4>
    </div>
    <div class="container my-4">
        <h5 id="raceTitle" class="mb-3 pixel-art-heading-2"></h5>
        <!-- Loading Indicator for Scored Results -->
        <div id="scoredLoading" class="loading-indicator mb-3 pixel-art-heading-2">
            Results loading...
            <div class="loading-bar"></div>
        </div>
        <table id="resultsTable">
            <tbody>
                <tr>
                    <td style="vertical-align: middle;">
                        <p>
                            <img src="/media/awards/medal_first.png" style="float:left; width: 16px; height: 26px; image-rendering: pixelated; margin-right: 10px;">
                            <span id="firstPlace" class="pixel-art-body"></span>
                        </p>
                    </td>
                    <td style="vertical-align: middle;">
                        <p>
                            <img src="/media/awards/medal_second.png" style="float:left; width: 16px; height: 26px; image-rendering: pixelated; margin-right: 10px; margin-left: 10px;">
                            <span id="secondPlace" class="mb-3 pixel-art-body"></span>
                        </p>
                    </td>
                    <td style="vertical-align: middle;">
                        <p>
                            <img src="/media/awards/medal_third.png" style="float:left; width: 16px; height: 26px; image-rendering: pixelated; margin-right: 10px; margin-left: 10px;">
                            <span id="thirdPlace" class="mb-3 pixel-art-body"></span>
                        </p>
                    </td>
                </tr>
            </tbody>
        </table>
    
        <!-- Scrollable container for main results table -->
        <div class="table-responsive" style="overflow-x: auto; max-width: 100%;">
            <table id="mainResultsTable" class="table table-sm table-bordered">
                <thead id="tableHeader">
                    <!-- Header row will be inserted here -->
                </thead>
                <tbody id="tableBody">
                    <!-- Data rows will be inserted here -->
                </tbody>
            </table>
        </div>
        <div class="form-check form-switch">
            <label class="form-check-label" for="toggleScores">Show Detailed Scoring</label>
            <input class="form-check-input form-switch-input" type="checkbox" id="toggleScores">
        </div>
        <div id="lowestScores" class="mt-3">
            <!-- Lowest scores will be displayed here -->
        </div>
    </div>
</div>

<!-- Unscored Predictions Section -->
<div id="unscoredPredictions" style="display: none;"> <!-- Unscored Predictions Placeholder -->
    <div class="container my-3 d-flex justify-content-left">
        <h4 class="mb-3 pixel-art-heading-3">Unscored Predictions</h4>
    </div>
    <div class="container my-4">
        <h5 id="unscoredRaceTitle" class="mb-3 pixel-art-heading-2"></h5>
        <!-- Loading Indicator for Unscored Predictions -->
        <div id="unscoredLoading" class="loading-indicator mb-3 pixel-art-heading-2">
            Predictions loading...
            <div class="loading-bar"></div>
        </div>
        <!-- Scrollable container for unscored results table -->
        <div class="table-responsive" style="overflow-x: auto; max-width: 100%;">
            <table id="unscoredResultsTable" class="table table-sm table-bordered">
                <thead id="unscoredTableHeader">
                    <!-- Header row will be inserted here -->
                </thead>
                <tbody id="unscoredTableBody">
                    <!-- Data rows will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- No Display Section -->
<div id="noDisplay" style="display: none;"> <!-- No Display Placeholder -->
    <div class="container my-3 d-flex justify-content-left">
        <h4 class="mb-3 pixel-art-heading-2">No results to display</h4>
    </div>
</div>
        

        <div class="row g-4">
            <!-- Left Column: Latest Form -->
            <!-- Left Column: Latest Form / Player Standings -->
                <div class="col-md-6">
                    <h5 class="mb-3 pixel-art-heading-2">Player Standings</h5>
                    <table id="standings-table" class="table table-sm table-bordered">
                    <thead>
                        <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Standings rows will be injected here by JavaScript -->
                    </tbody>
                    </table>
                </div>

            <!-- Right Column: Quick Links -->
            <div class="col-md-6">
                <h5 class="mb-3 pixel-art-heading-2">Team Standings</h5>
                <table id="standings-team-table" class="table table-sm table-bordered">
                  <thead>
                    <tr>
                      <th>Rank</th>
                      <th>Team</th>
                      <th>Score</th>
                    </tr>
                  </thead>
                  <tbody>
                    <!-- Team standings will be inserted here dynamically -->
                  </tbody>
                </table>
              </div>
              
        <hr>
        <div class="container my-5">
            <pre class="mb-3 pixel-art-heading-3"><img src="/media/awards/trophy.png" style="float:left; width: 32px; height: 38px; image-rendering: pixelated;"> Past Champions</pre>
            <p>
                2024 - James<br>
                2023 - Ethan<br>
                2022 - Ethan
            </p>
        </div>
    </main>
 
    <footer class="bg-light text-black text-center py-1 pixel-art-body-smallx">
        <p>&copy; 2024 F1 Predictions Form</p>
    </footer>

    <!-- Bootstrap JS Bundle (Local) -->
    <script src="/js/bootstrap.bundle.min.js"></script>

    <script>
        // Fetch the race details from form_details and calendar tables
        async function fetchRaceDetails() {
            try {
                // Fetch the race number from form_details
                const { data: formDetails, error: formDetailsError } = await supabase
                    .from('form_details')
                    .select('race_number')
                    .eq('id', 1)
                    .single();
    
                if (formDetailsError) {
                    console.error('Error fetching form details:', formDetailsError);
                    return null;
                }
    
                const raceNumber = formDetails.race_number;
    
                // Fetch the race details from the calendar table
                const { data: raceDetails, error: raceDetailsError } = await supabase
                    .from('calendar')
                    .select('*')
                    .eq('race_number', raceNumber)
                    .single();
    
                if (raceDetailsError) {
                    console.error('Error fetching race details:', raceDetailsError);
                    return null;
                }
    
                return raceDetails;
            } catch (error) {
                console.error('Error fetching race details:', error);
                return null;
            }
        }
    
        // Update the latest form button with the current race name
        async function updateLatestFormButton(raceDetails) {
            if (raceDetails) {
                document.getElementById("latest-form-button").textContent = `${raceDetails.name} GP Form`;
            } else {
                document.getElementById("latest-form-button").textContent = "Error loading form";
            }
        }
    
        async function updateNextRaceInfo(raceDetails) {
  if (!raceDetails) {
    document.getElementById("next-race-info").innerHTML = "<p>Error loading next race.</p>";
    return;
  }

  const raceDate = new Date(raceDetails.date);
  if (isNaN(raceDate)) {
    console.error("Invalid date format for next race:", raceDetails.date);
    document.getElementById("next-race-info").innerHTML = "<p>Invalid race date.</p>";
    return;
  }

  const flagUrl = `/media/flags/${raceDetails.country.toLowerCase()}.png`;

  document.getElementById("next-race-info").innerHTML = `
  <img src="${flagUrl}" alt="${raceDetails.country} Flag" style="width: 64px; height: 36px; image-rendering: pixelated;">
  <h6 class="mt-2 pixel-art-body-small">${raceDetails.name} GP</h6>
  <div id="countdown-timer" class="mt-2" style="font-size: 0.8rem; text-align: center; display: inline-block;">
    <strong>Time left:</strong> <span id="countdown"></span>
  </div>
`;

// Show the countdown container (it should now size to its content)
document.getElementById("countdown-timer").style.display = "inline-block";

// Start the generic countdown as before
startGenericCountdown(raceDate, "countdown", function() {
  const countdownEl = document.getElementById("countdown");
  countdownEl.style.color = "green";
});
}
    
        /**
 * startGenericCountdown:
 * Starts a countdown that updates every second.
 * @param {Date} targetDate - The date/time to count down to.
 * @param {string} countdownElementId - The id of the element where the countdown text will be displayed.
 * @param {function} [onEnd] - Optional callback to execute when countdown ends.
 */
function startGenericCountdown(targetDate, countdownElementId, onEnd) {
  const countdownElement = document.getElementById(countdownElementId);

  if (!countdownElement) {
    console.error(`Element with id "${countdownElementId}" not found.`);
    return;
  }

  function updateCountdown() {
    const now = new Date();
    const timeLeft = targetDate - now;

    if (timeLeft <= 0) {
      clearInterval(timer);
      countdownElement.textContent = "Time's up!";
      countdownElement.classList.add("countdown-update");
      if (typeof onEnd === "function") {
        onEnd();
      }
      return;
    }

    // Calculate time parts
    const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
    const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

    // Build the countdown stringâ€”omit days if zero
    let countdownStr = "";
    if (days > 0) {
      countdownStr += `${days}d `;
    }
    countdownStr += `${hours}h ${minutes}m ${seconds}s`;

    countdownElement.textContent = countdownStr;

    // Restart animation by reflow (for the pixel pulse effect)
    countdownElement.classList.remove("countdown-update");
    void countdownElement.offsetWidth;
    countdownElement.classList.add("countdown-update");
  }

  // Initial update then update every second
  updateCountdown();
  const timer = setInterval(updateCountdown, 1000);
}
        
        // Fetch the form status from form_details table
async function fetchFormStatus() {
    try {
        const { data: formDetails, error: formDetailsError } = await supabase
            .from('form_details')
            .select('form_enabled')
            .eq('id', 1)
            .single();

        if (formDetailsError) {
            console.error('Error fetching form status:', formDetailsError);
            return false;
        }

        return formDetails.form_enabled;
    } catch (error) {
        console.error('Error fetching form status:', error);
        return false;
    }
}

// Update the latest form button based on form status
async function updateFormButtonStatus() {
    const formEnabled = await fetchFormStatus();
    const formButton = document.getElementById('latest-form-button');

    if (formEnabled) {
        formButton.disabled = false;
    } else {
        formButton.disabled = true;
    }
}

document.addEventListener('DOMContentLoaded', async () => {
    // Fetch race details
    const raceDetails = await fetchRaceDetails();

    // Update the latest form button with the current race name
    await updateLatestFormButton(raceDetails);

    // Update the next race info and initialize the countdown
    await updateNextRaceInfo(raceDetails);

    // Update the form button status based on form_enabled
    await updateFormButtonStatus();

    // Add event listener to the form button
    const formButton = document.getElementById('latest-form-button');
    const formLink = document.getElementById('latest-form-link');

    formButton.addEventListener('click', (event) => {
        if (formButton.disabled) {
            event.preventDefault();
        } else {
            formLink.href = '/form';
        }
    });
});

// RESULTS DISPLAY CODE
document.addEventListener("DOMContentLoaded", async () => {
    // ----- INITIAL DATA FETCHING -----

    // Fetch initial form details
    const { data: formDetails, error: formDetailsError } = await supabase
        .from('form_details')
        .select('*')
        .eq('id', 1)
        .single();

    if (formDetailsError) {
        console.error('Error fetching form details:', formDetailsError.message);
        return;
    }

    const { results_display_race_number, results_display_type, current_year } = formDetails;

    // Fetch the entire form configuration.
    // Each row represents one question. (e.g., id, text, response_type, enabled, etc.)
    const { data: formConfiguration, error: formConfigurationError } = await supabase
        .from('form_configuration')
        .select('*');
    if (formConfigurationError) {
        console.error('Error fetching form configuration:', formConfigurationError.message);
        return;
    }

    // Fetch race details
    const { data: raceDetails, error: raceDetailsError } = await supabase
        .from('calendar')
        .select('*')
        .eq('race_number', results_display_race_number)
        .single();

    if (raceDetailsError) {
        console.error('Error fetching race details:', raceDetailsError.message);
        return;
    }
    const raceName = `${raceDetails.name} GP`;

    // Fetch drivers and constructors
    const { data: drivers, error: driversError } = await supabase
        .from('drivers')
        .select('*');
    if (driversError) {
        console.error('Error fetching drivers:', driversError.message);
        return;
    }

    const { data: constructors, error: constructorsError } = await supabase
        .from('constructors')
        .select('*');
    if (constructorsError) {
        console.error('Error fetching constructors:', constructorsError.message);
        return;
    }

    // ----- ADDITIONAL TABLE FETCHES -----
    // Download the full players table (used for lookups in the conversion function)
    const { data: playersTable, error: playersTableError } = await supabase
        .from('players')
        .select('*');
    if (playersTableError) {
        console.error('Error fetching players table:', playersTableError.message);
        return;
    }

    // ----- UNORSCED PREDICTIONS SECTION -----
    if (results_display_type === 'Unscored Predictions') {
        // Show/hide appropriate sections
        document.getElementById('unscoredPredictions').style.display = 'block';
        document.getElementById('scoredResults').style.display = 'none';
        document.getElementById('noDisplay').style.display = 'none';

        // Set race title
        document.getElementById('unscoredRaceTitle').textContent = `${raceName} ${current_year} - Predictions`;

        // Show loading indicator for Unscored Predictions
        document.getElementById('unscoredLoading').style.display = 'block';

        // Fetch form responses from form_raw for the current race
        const { data: formResponses, error: formResponsesError } = await supabase
            .from('form_raw')
            .select('*')
            .eq('race_number', results_display_race_number);
        if (formResponsesError) {
            console.error('Error fetching form responses:', formResponsesError.message);
            return;
        }

        // Filter out responses with player_id = 0 (only valid responses)
        const formResponsePlayers = formResponses.filter(response => response.player_id !== 0);

        // --- Define the Conversion Function ---
        function convertResponseToText(response, responseType) {
            if (response === null || response === undefined) return '';
            switch (responseType) {
                case 'Select - Name List':
                    return playersTable.find(player => player.id === parseInt(response))?.name || response;
                case 'Select - Driver List':
                case 'Select - Driver List + DNF':
                    if (response === 'no-dnf') {
                        return 'No DNFs';
                    }
                    return drivers.find(driver => driver.id === parseInt(response))?.abbreviation || response;
                case 'Select - Team List':
                    return constructors.find(constructor => constructor.id === parseInt(response))?.name || response;
                case 'Radio - Yes/No':
                    return response.toLowerCase() === 'yes' ? 'Yes' : 'No';
                case 'Radio - Heads/Tails':
                    return response.toLowerCase() === 'heads' ? 'Heads' : 'Tails';
                default:
                    return response;
            }
        }

        // --- Build the Table Header ---
        const headerRow = document.createElement('tr');
        headerRow.classList.add('header');
        headerRow.innerHTML = '<th>Name</th>';
        formResponsePlayers.forEach(response => {
            const player = playersTable.find(p => p.id === response.player_id);
            const th = document.createElement('th');
            th.textContent = player?.name || response.player_name || 'Unknown';
            headerRow.appendChild(th);
        });
        document.getElementById('unscoredTableHeader').appendChild(headerRow);

        // --- Build the Table Body ---
        const tableBody = document.getElementById('unscoredTableBody');
        formConfiguration.forEach(question => {
            // Only process enabled questions.
            if (!question.enabled) return;
            // Skip the question used for the "Name" column (assumed to be id === 1)
            if (question.id === 1) return;

            const row = document.createElement('tr');
            // First cell: the question text
            row.innerHTML = `<td>${question.text}</td>`;
            // For each player's response, add a cell.
            formResponsePlayers.forEach(response => {
                const td = document.createElement('td');
                const rawResponse = response[`form_id_${question.id}`];
                td.textContent = convertResponseToText(rawResponse, question.response_type);
                row.appendChild(td);
            });
            tableBody.appendChild(row);
        });

        // --- Apply Formatting ---
        const applyFormatting = (cell, value) => {
            if (/^[A-Z]{3}$/.test(value)) {
                const driver = drivers.find(driver => driver.abbreviation === value);
                if (driver) {
                    const constructor = constructors.find(constructor => constructor.id === driver.constructor_id);
                    if (constructor) {
                        cell.style.backgroundColor = constructor.background_colour;
                        cell.style.color = constructor.text_colour;
                    }
                }
            } else if (/^\d+$/.test(value)) {
                // Numeric values: no additional formatting.
            } else if (value === 'Yes') {
                cell.style.color = 'green';
                cell.style.backgroundColor = 'white';
            } else if (value === 'No') {
                cell.style.color = 'red';
                cell.style.backgroundColor = 'white';
            } else {
                const constructor = constructors.find(constructor => constructor.name === value);
                if (constructor) {
                    cell.style.backgroundColor = constructor.background_colour;
                    cell.style.color = constructor.text_colour;
                }
            }
        };

        document.querySelectorAll('#unscoredTableBody td').forEach(cell => {
            applyFormatting(cell, cell.textContent);
        });

        // Hide the loading indicator after the unscored table has been built.
        document.getElementById('unscoredLoading').style.display = 'none';

    // --- Scored Results Section Begins ---
    } else if (results_display_type === 'Scored Results') { 
        document.getElementById('unscoredPredictions').style.display = 'none';
        document.getElementById('scoredResults').style.display = 'block';
        document.getElementById('noDisplay').style.display = 'none';

        // Set race title
        document.getElementById('raceTitle').textContent = `${raceName} ${current_year} - Results`;

        // Show loading indicator for Scored Results
        document.getElementById('scoredLoading').style.display = 'block';

        // Fetch form responses from form_responses_{current_year}
        const { data: formResponses, error: formResponsesError } = await supabase
            .from(`form_responses_${current_year}`)
            .select('*')
            .eq('race_number', results_display_race_number);
        if (formResponsesError) {
            console.error('Error fetching form responses:', formResponsesError.message);
            return;
        }

        // Process form responses
        const questions = formResponses.find(response => response.entry_type === 'questions');
        const results = formResponses.find(response => response.entry_type === 'results');
        console.log('Results object:', results);
        const players = formResponses.filter(response => response.entry_type === 'player');
        const lowestScores = formResponses.filter(response => response.entry_type === 'player_lowest_score');

        // Create header row for scored results
        const headerRow = document.createElement('tr');
        headerRow.classList.add('header');
        headerRow.innerHTML = '<th>Name</th>';
        players.forEach(player => {
            const th = document.createElement('th');
            th.textContent = player.player_name;
            headerRow.appendChild(th);
        });
        headerRow.innerHTML += '<th style="background-color: white; border-top: none; border-bottom: none;"></th><th>Results</th>';
        document.getElementById('tableHeader').appendChild(headerRow);

        // Create data rows for scored results
        const tableBody = document.getElementById('tableBody');
        const createRow = (id, label) => {
            console.log(`Creating row for ID: ${id}, Label: ${label}`);
            const isTotalColumn = ['subtotal_1', 'subtotal_2', 'subtotal_3', 'subtotal_4', 'grand_total'].includes(id);
            if (isTotalColumn) {
                console.log(`Checking total column: ${id}`);
                const row = document.createElement('tr');
                row.innerHTML = `<td>${label}</td>`;
                players.forEach(player => {
                    console.log(`Processing player: ${player.player_name}, Player ID: ${player.player_id}`);
                    const td = document.createElement('td');
                    td.textContent = player[id];
                    console.log(`Player ${player.player_name} score for ${id}: ${player[id]}`);
                    td.className = `${id}_score`;
                    td.dataset.playerId = player.player_id;
                    row.appendChild(td);
                });
                row.innerHTML += `<td style="background-color: white;"></td><td></td>`;
                console.log(`Appending row: ${row.innerHTML}`);
                tableBody.appendChild(row);
            } else {
                console.log(`Checking form_id column: form_id_${id}`);
                if (results[`form_id_${id}`] !== null) {
                    console.log(`Results for form_id_${id}: ${results[`form_id_${id}`]}`);
                    const row = document.createElement('tr');
                    row.innerHTML = `<td>${label}</td>`;
                    players.forEach(player => {
                        console.log(`Processing player: ${player.player_name}, Player ID: ${player.player_id}`);
                        const td = document.createElement('td');
                        td.textContent = player[`form_id_${id}`];
                        console.log(`Player ${player.player_name} score for form_id_${id}: ${player[`form_id_${id}`]}`);
                        td.className = `form_id_${id}_score`;
                        td.dataset.playerId = player.player_id;
                        row.appendChild(td);
                    });
                    row.innerHTML += `<td style="background-color: white;"></td><td>${results[`form_id_${id}`]}</td>`;
                    console.log(`Appending row: ${row.innerHTML}`);
                    tableBody.appendChild(row);
                } else {
                    console.log(`No results found for form_id_${id}`);
                }
            }
        };

        // Add question rows for scored results
        for (let i = 2; i <= 7; i++) {
            createRow(i, questions[`form_id_${i}`]);
        }
        createRow('subtotal_2', 'Subtotal');
        tableBody.innerHTML += '<tr class="spacer-row"><td colspan="100%" style="background-color: white;"></td></tr>';
        for (let i = 8; i <= 27; i++) {
            createRow(i, questions[`form_id_${i}`]);
        }
        createRow('subtotal_3', 'Subtotal');
        tableBody.innerHTML += '<tr class="spacer-row"><td colspan="100%" style="background-color: white;"></td></tr>';
        createRow(28, questions[`form_id_28`]);
        tableBody.innerHTML += '<tr class="spacer-row"><td colspan="100%" style="background-color: white;"></td></tr>';
        createRow('grand_total', 'Grand Total');

        // Apply formatting for scored results
        const applyFormattingScored = (cell, value) => {
            if (/^[A-Z]{3}$/.test(value)) {
                const driver = drivers.find(driver => driver.abbreviation === value);
                if (driver) {
                    const constructor = constructors.find(constructor => constructor.id === driver.constructor_id);
                    if (constructor) {
                        cell.style.backgroundColor = constructor.background_colour;
                        cell.style.color = constructor.text_colour;
                    }
                }
            } else if (/^\d+$/.test(value)) {
                // No additional formatting for numeric values.
            } else if (value === 'Yes') {
                cell.style.color = 'green';
                cell.style.backgroundColor = 'white';
            } else if (value === 'No') {
                cell.style.color = 'red';
                cell.style.backgroundColor = 'white';
            } else {
                const constructor = constructors.find(constructor => constructor.name === value);
                if (constructor) {
                    cell.style.backgroundColor = constructor.background_colour;
                    cell.style.color = constructor.text_colour;
                }
            }
        };

        document.querySelectorAll('#mainResultsTable tbody td').forEach(cell => {
            applyFormattingScored(cell, cell.textContent);
        });

        // Highlight highest scores, closest scores, and display top scorers
        const highlightHighest = (selector, colors) => {
            const cells = Array.from(document.querySelectorAll(selector));
            const values = cells.map(cell => parseFloat(cell.textContent)).filter(value => !isNaN(value));
            const sortedValues = [...new Set(values)].sort((a, b) => b - a);
            cells.forEach(cell => {
                const cellValue = parseFloat(cell.textContent);
                const rank = sortedValues.indexOf(cellValue);
                if (rank >= 0 && rank < colors.length) {
                    cell.style.backgroundColor = colors[rank];
                    cell.style.color = 'black';
                }
            });
        };

        const highlightClosestScore = (selector, color) => {
            const cells = Array.from(document.querySelectorAll(selector));
            cells.forEach(cell => {
                const playerId = cell.dataset.playerId;
                const player = players.find(player => player.player_id == playerId);
                const playerScore = player ? player.form_id_28_score : null;
                if (playerScore === 1) {
                    cell.style.backgroundColor = color;
                    cell.style.color = 'black';
                } else {
                    cell.style.backgroundColor = '';
                    cell.style.color = '';
                }
            });
        };

        highlightHighest('td.subtotal_2_score', ['lightyellow']);
        highlightHighest('td.subtotal_3_score', ['lightyellow']);
        highlightHighest('td.grand_total_score', ['gold', 'silver', '#cd7f32']);
        highlightClosestScore('td.form_id_28_score', 'lightyellow');

        const grandTotals = players.map(player => ({
            name: player.player_name,
            total: parseFloat(player.grand_total)
        })).sort((a, b) => b.total - a.total);
        document.getElementById('firstPlace').textContent = grandTotals[0]?.name || '';
        document.getElementById('secondPlace').textContent = grandTotals[1]?.name || '';
        document.getElementById('thirdPlace').textContent = grandTotals[2]?.name || '';

        document.getElementById('toggleScores').addEventListener('change', (event) => {
            const showScores = event.target.checked;
            document.querySelectorAll('#mainResultsTable tbody td').forEach(cell => {
                const idMatch = cell.className.match(/form_id_(\d+)_score/);
                if (idMatch) {
                    const scoreId = `form_id_${idMatch[1]}_score`;
                    const playerId = cell.dataset.playerId;
                    const player = players.find(player => player.player_id == playerId);
                    const playerScore = player ? player[scoreId] : null;
                    if (playerScore !== null) {
                        cell.textContent = showScores ? `${cell.textContent} (${playerScore})` : cell.textContent.split(' ')[0];
                    }
                }
            });
        });

        const lowestScoresDiv = document.getElementById('lowestScores');
        if (lowestScores.length > 0) {
            const lowestScoresText = lowestScores.map(player => player.player_name).join(', ');
            lowestScoresDiv.textContent = `Lowest Score: ${lowestScoresText}`;
        }

        // Hide the loading indicator after the scored results table is built.
        document.getElementById('scoredLoading').style.display = 'none';
    } else if (results_display_type === 'No Display') {
        document.getElementById('unscoredPredictions').style.display = 'none';
        document.getElementById('scoredResults').style.display = 'none';
        document.getElementById('noDisplay').style.display = 'block';
    }
});

// --- Player Standings Tables ---
        async function getTable(tableName) {
        const { data, error } = await supabase.from(tableName).select('*');
        if (error) {
            console.error(`Error fetching ${tableName}:`, error);
            throw error;
        }
        return data;
        }

        async function loadHomeStandings() {
        try {
            // 1. Retrieve the current year from form_details.
            const formDetails = await getTable('form_details');
            if (!formDetails || formDetails.length === 0) {
            console.error("No form_details found.");
            return;
            }
            const currentYear = formDetails[0].current_year;
            console.log("Current Year:", currentYear);

            // 2. Retrieve the full season_player_{year} table.
            const seasonTableName = `season_player_${currentYear}`;
            const seasonData = await getTable(seasonTableName);
            console.log("Season Data:", seasonData);

            if (!seasonData || seasonData.length === 0) {
            document.querySelector("#standings-table tbody").innerHTML =
                "<tr><td colspan='3'>No season data available.</td></tr>";
            return;
            }

            // 3. Exclude the special "Race Names" row (player_id === 0).
            const playerRows = seasonData.filter(row => row.player_id !== 0);
            if (playerRows.length === 0) {
            document.querySelector("#standings-table tbody").innerHTML =
                "<tr><td colspan='3'>No player data available.</td></tr>";
            return;
            }

            // 4. Determine the last race that has been scored.
            let lastRace = 0;
            const raceNamesRow = seasonData.find(row => row.player_id === 0);
            if (raceNamesRow) {
            // Assume columns are named race_1, race_2, ..., race_32.
            for (let i = 1; i <= 32; i++) {
                const col = `race_${i}`;
                if (raceNamesRow[col] !== null && raceNamesRow[col] !== "") {
                lastRace = i;
                } else {
                break;
                }
            }
            }
            console.log("Last race with data:", lastRace);
            if (lastRace === 0) {
            document.querySelector("#standings-table tbody").innerHTML =
                "<tr><td colspan='3'>No race scores available yet.</td></tr>";
            return;
            }

            // 5. Compute current total scores (summing races 1 to lastRace) for each player.
            const standings = playerRows.map(row => {
            let total = 0;
            let prevTotal = 0;
            for (let i = 1; i <= lastRace; i++) {
                const col = `race_${i}`;
                const rawVal = row[col];
                if (rawVal !== null && rawVal !== "") {
                // Remove any "(LS)" suffix and trim.
                const numStr = rawVal.replace(/\(LS\)/, "").trim();
                const num = parseFloat(numStr);
                if (!isNaN(num)) {
                    total += num;
                    if (i < lastRace) {
                    prevTotal += num;
                    }
                }
                }
            }
            return {
                player_id: row.player_id,
                player_name: row.player_name,
                total: total,
                prevTotal: prevTotal
            };
            });

            // 6. Sort standings descending by current total score.
            standings.sort((a, b) => b.total - a.total);

            // 7. Assign current ranks with ties receiving the same rank.
            let currentRank = 1;
            let prevScore = null;
            const currentRankMap = {};
            standings.forEach((player, index) => {
            if (prevScore === null || player.total !== prevScore) {
                currentRank = index + 1;
            }
            currentRankMap[player.player_id] = currentRank;
            prevScore = player.total;
            });

            // 8. Compute previous standings if lastRace > 1.
            const prevRankMap = {};
            if (lastRace > 1) {
            const prevStandings = [...standings].sort((a, b) => b.prevTotal - a.prevTotal);
            let prevRank = 1;
            let prevPrevScore = null;
            prevStandings.forEach((player, index) => {
                if (prevPrevScore === null || player.prevTotal !== prevPrevScore) {
                prevRank = index + 1;
                }
                prevRankMap[player.player_id] = prevRank;
                prevPrevScore = player.prevTotal;
            });
            }

            // 9. Build HTML rows.
            let html = "";
            standings.forEach(player => {
            const currRank = currentRankMap[player.player_id];
            let movement = "";
            if (lastRace > 1 && prevRankMap[player.player_id] !== undefined) {
                const diff = prevRankMap[player.player_id] - currRank;
                if (diff > 0) {
                movement = `(+${diff})`;
                } else if (diff < 0) {
                movement = `(${diff})`;
                } else {
                movement = "(=)";
                }
            }
            html += `<tr>
                        <td>${currRank} ${movement}</td>
                        <td>${player.player_name}</td>
                        <td>${player.total}</td>
                    </tr>`;
            });
            document.querySelector("#standings-table tbody").innerHTML = html;
        } catch (err) {
            console.error("loadHomeStandings error:", err);
            document.querySelector("#standings-table tbody").innerHTML =
            `<tr><td colspan="3">Error loading standings: ${err.message}</td></tr>`;
        }
        }

        document.addEventListener("DOMContentLoaded", () => {
        loadHomeStandings();
        });

// --- Season Team Standings ---
        // --- Helper: Retrieve an entire table from Supabase (assumed to be defined already) ---

// --- Team Standings for Home Page ---
async function loadHomeTeamStandings() {
  try {
    // 1. Retrieve the current year from form_details.
    const formDetails = await getTable('form_details');
    if (!formDetails || formDetails.length === 0) {
      console.error("No form_details found.");
      return;
    }
    const currentYear = formDetails[0].current_year;
    console.log("Current Year:", currentYear);

    // 2. Retrieve the full season_team_{year} table.
    const seasonTeamTable = `season_team_${currentYear}`;
    const seasonTeamData = await getTable(seasonTeamTable);
    console.log("Season Team Data:", seasonTeamData);

    if (!seasonTeamData || seasonTeamData.length === 0) {
      document.querySelector("#standings-team-table tbody").innerHTML =
        "<tr><td colspan='3'>No season team data available.</td></tr>";
      return;
    }

    // 3. Exclude the special "Race Names" row (team_id === 0).
    const teamRows = seasonTeamData.filter(row => row.team_id !== 0);
    if (teamRows.length === 0) {
      document.querySelector("#standings-team-table tbody").innerHTML =
        "<tr><td colspan='3'>No team data available.</td></tr>";
      return;
    }

    // 4. Determine the last race that has been scored using the Race Names row.
    let lastRace = 0;
    const raceNamesRow = seasonTeamData.find(row => row.team_id === 0);
    if (raceNamesRow) {
      // Assume race columns are named race_1, race_2, ..., race_32.
      for (let i = 1; i <= 32; i++) {
        const col = `race_${i}`;
        if (raceNamesRow[col] !== null && raceNamesRow[col] !== "") {
          lastRace = i;
        } else {
          break;
        }
      }
    }
    console.log("Last race with data:", lastRace);
    if (lastRace === 0) {
      document.querySelector("#standings-team-table tbody").innerHTML =
        "<tr><td colspan='3'>No race scores available yet.</td></tr>";
      return;
    }

    // 5. Compute current total scores (summing races 1 to lastRace) for each team.
    //    We strip any extra tags (e.g. "(double)") using a regex that removes text within parentheses.
    const standings = teamRows.map(row => {
      let total = 0;
      let prevTotal = 0;
      for (let i = 1; i <= lastRace; i++) {
        const col = `race_${i}`;
        const rawVal = row[col];
        if (rawVal !== null && rawVal !== "") {
          // Remove any tags such as "(double)" or "(aero)".
          const numStr = rawVal.replace(/\(.*?\)/g, "").trim();
          const num = parseFloat(numStr);
          if (!isNaN(num)) {
            total += num;
            if (i < lastRace) {
              prevTotal += num;
            }
          }
        }
      }
      return {
        team_id: row.team_id,
        team_name: row.team_name,
        total: total,
        prevTotal: prevTotal
      };
    });

    // 6. Sort standings descending by current total score.
    standings.sort((a, b) => b.total - a.total);

    // 7. Assign current ranks with ties receiving the same rank.
    let currentRank = 1;
    let prevScore = null;
    const currentRankMap = {};
    standings.forEach((team, index) => {
      if (prevScore === null || team.total !== prevScore) {
        currentRank = index + 1;
      }
      currentRankMap[team.team_id] = currentRank;
      prevScore = team.total;
    });

    // 8. Compute previous standings if lastRace > 1.
    const prevRankMap = {};
    if (lastRace > 1) {
      // Create a copy and sort by the total up to race lastRace-1.
      const prevStandings = [...standings].sort((a, b) => b.prevTotal - a.prevTotal);
      let prevRank = 1;
      let prevPrevScore = null;
      prevStandings.forEach((team, index) => {
        if (prevPrevScore === null || team.prevTotal !== prevPrevScore) {
          prevRank = index + 1;
        }
        prevRankMap[team.team_id] = prevRank;
        prevPrevScore = team.prevTotal;
      });
    }

    // 9. Build HTML rows for each team.
    let html = "";
    standings.forEach(team => {
      const currRank = currentRankMap[team.team_id];
      let movement = "";
      if (lastRace > 1 && prevRankMap[team.team_id] !== undefined) {
        const diff = prevRankMap[team.team_id] - currRank;
        if (diff > 0) {
          movement = `(+${diff})`;
        } else if (diff < 0) {
          movement = `(${diff})`;
        } else {
          movement = "(=)";
        }
      }
      html += `<tr>
                 <td>${currRank} ${movement}</td>
                 <td>${team.team_name}</td>
                 <td>${team.total}</td>
               </tr>`;
    });
    document.querySelector("#standings-team-table tbody").innerHTML = html;
  } catch (err) {
    console.error("loadHomeTeamStandings error:", err);
    document.querySelector("#standings-team-table tbody").innerHTML =
      `<tr><td colspan="3">Error loading team standings: ${err.message}</td></tr>`;
  }
}

// --- Initialize Team Standings on DOMContentLoaded ---
document.addEventListener("DOMContentLoaded", () => {
  loadHomeTeamStandings();
});

    </script>
</body>
</html>